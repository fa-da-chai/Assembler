# include <stdio.h>
# include <stdlib.h>
# include <iostream>
# include <string.h>
# include <fstream>
# include <iomanip>
# include <vector>
# include <sstream>
# include <algorithm>
# include <map>

using namespace std ;

struct Token {
  string tokenStr ;
  int type ;
  int value ;
};

struct OutputToken {
  int line ;
  int loc ; // out for hex
  string source ;
  string machineCode ;	
};

class Hash {
  vector<string> hashMap ;
  
  public :
    void Init() {
      hashMap.resize( 100 ) ;
      for ( int i = 0 ; i < hashMap.size() ; i++ ) {
	    hashMap[i] = "" ;
      } // for
	} // BuildHashMap()
	
    int Insert( string str ) ; // return token value
    void Clear() {
	  hashMap.clear() ;
      Init() ;
	} // Clear()

  private :
	int GetHashValue( string str ) ;
};

vector<string> GetTableData( string fileName, bool &isOpen ) ;
bool IsDelimiter( char ch, vector<string> table4 ) ;
bool IsNumber( string str ) ;
string ToUpper( string str ) ;
string ToLower( string str ) ;
void UserFrame() ;
void Pass1( vector< vector<string> > sicTable, vector<Token> tokenTable,
            map<string, int> &symbolTable, vector<OutputToken> &outputTokenList ) ;

void Pass2( vector<Token> tokenTable, map<string, int> symbolTable,
            map<string, pair<string, int> > instructionSet, vector<OutputToken> &outputTokenList ) ;

string DecToHex( int decValue ) ;
int HexToDec( string hexValue ) ;
map<string, pair<string, int> > GetOpcodeSet() ;
int GetHashValue( string str ) ;
void GetTokenLine( vector<Token> tokenTable, int &begin, int &end, int &line ) ; // use begin and end to specified a line
void ClassifyToken( vector<Token> tokenTable, int begin, int end, bool &literal,
                    Token &label, Token &opcode, bool &e, bool &x, char &addrMod, Token &op1, Token&op2 ) ;
void OutputResult( vector<OutputToken> outputTokenList, fstream &outfile ) ;
void Pass1XE( vector< vector<string> > sicTable, vector<Token> tokenTable, map<string, pair<string, int> > instructionSet,
            map<string, int> &symbolTable, vector<OutputToken> &outputTokenList, map<int, pair<Token, int> > &literalTable ) ;

void Pass2XE( vector<Token> tokenTable, map<string, int> symbolTable, map<string, pair<string, int> > instructionSet,
              vector<OutputToken> &outputTokenList, map<int, pair<Token, int> > literalTable ) ;

int main() {
  string infileName, outfileName ; 
  fstream infile, outfile ;
  vector< vector<string> > sicTable ; // table1, table2.......
  Hash table5, table6, table7 ;
  bool isOpen ;
  table5.Init() ;
  table6.Init() ;
  table7.Init() ; 
  vector<Token> tokenTable ;
  vector<OutputToken> outputTokenList ;
  for ( int i = 0 ; i < 4 ; i++ ) {
	stringstream ss ;
    ss << i+1 ;
    string temp ;
    ss >> temp ;
    sicTable.push_back( GetTableData( "SICTABLE/Table" + temp + ".table", isOpen ) ) ;
  } // for 
 
  map<string, pair<string, int> > instructionSet ;
  instructionSet = GetOpcodeSet() ;
  // ------------------------up get table up-------------------------- 
  string cmd ;
  UserFrame() ;
  cin >> cmd ;
  while ( cmd != "1" && cmd != "2" && cmd != "3" ) {
    UserFrame() ;
    cin >> cmd ;	
  } // while

  while ( cmd != "3" ) {
    cout << "\nEnter a input file:" ;
    cin >> infileName ;
    infile.open( ( infileName + ".txt" ).c_str(), fstream::in ) ;
    while ( !infile.is_open() ) {
	  cout << "\nCan not find the file\n" ;
      cout << "Please enter again:" ;
      cin >> infileName ;
      infile.open( ( infileName + ".txt" ).c_str(), fstream::in ) ;
    } // while

    outfileName = infileName + "output.txt" ;
    outfile.open( ( outfileName ).c_str(), fstream::out ) ;
    // ----------------------- get token ----------------------------
    outputTokenList.clear() ;
    tokenTable.clear() ;
    table5.Clear() ;
    table6.Clear() ;
    table7.Clear() ; 
    char cStr[256] ;
    string buf, tokenStr ;
    int pre, pos ;
    int outputHeadIndex = 0 ;
    
  while ( infile.getline( cStr, 256, '\n' ) ) {
    buf.assign( cStr ) ; 
    OutputToken tempOutputToken ;
    tempOutputToken.source = buf ;
    tempOutputToken.line = -1 ;
    tempOutputToken.loc = -1 ;
    outputTokenList.push_back( tempOutputToken ) ;
    buf = buf + "\n" ;
	int bufIndex = 0 ;
    pre = 1 ;
    for ( pre = bufIndex ; bufIndex < buf.size() ; bufIndex++ ) {
	  if ( IsDelimiter( buf[bufIndex], sicTable[3] ) ) {
	    Token token ;
	    pos = bufIndex ;
	    // get token
	    tokenStr = buf.substr( pre, pos-pre ) ;
	    // put token into token table and hash table
        // determine the token in which table
        if ( tokenStr.size() != 0 && ( tokenStr != " "  || tokenStr != "\t" ||
		                               tokenStr != "\n" || tokenStr != "." ) ) {
          bool inTable = false ;
          int sicTableIndex, sicTableIndex2 ;
          for ( sicTableIndex = 0 ; !inTable && sicTableIndex < sicTable.size() ; sicTableIndex++ ) {
            if ( sicTableIndex == 0 ) { // token toLower
              tokenStr = ToLower( tokenStr ) ;
			} //
			
			else if ( sicTableIndex == 3 )
			  tokenStr = tokenStr ;
			  
			else { // token toupper
			  tokenStr = ToUpper( tokenStr ) ;
			} // else  
			
	        for ( sicTableIndex2 = 0 ; !inTable && sicTableIndex2 < sicTable[sicTableIndex].size() ; sicTableIndex2++ ) {
	          if ( tokenStr == sicTable[sicTableIndex][sicTableIndex2] ) {
	            inTable = true ;
              } // if
            } // for
          } // for   

          if ( buf[bufIndex] == '\'' && tokenStr.size() == 1 )
            inTable = false ;
          // if it in table1,2,3,4 then get its table num and value
          if ( inTable ) {
	        token.tokenStr = tokenStr ;
            token.type = sicTableIndex ;
            token.value = sicTableIndex2 ;
          } // if
          // if not,determine it is label,string or constant 
          else { // not in table
	        if ( buf[bufIndex] == '\'' ) { // table7 string
	          pre = pos ; // ï¿¥y3B2z2A?@-O'!A?a3B2z|r|e?oRe 
              if ( buf[bufIndex-1] != 'c' && buf[bufIndex-1] != 'C' &&
                   buf[bufIndex-1] != 'x' && buf[bufIndex-1] != 'X' ) {
	            string temp = "" ;
                temp += buf[bufIndex-1] ;
	            bool finded = false ;
                int i, j ;
	            for ( i = 0 ; i < sicTable.size() && !finded ; i++ ) {
	              for ( j = 0 ; j < sicTable[i].size() && !finded ; j++ ) {
                    if ( temp == sicTable[i][j])
                      finded  = true ;
                  } // for
                } // for

                token.tokenStr = temp ;
                if ( finded ) {
                  token.type = i ;
                  token.value = j ;
                } // if

                else {
	              if ( temp[0] >= '0' && temp[0] <= '9' ) {
                    token.type = 6 ;
                    token.value = table6.Insert( temp ) ;
                  } // if

                  else {
                    token.type = 5 ;
                    token.value = table5.Insert( temp ) ;
                  } // else
                } // else

                tokenTable.push_back( token ) ;
              } // if

              bufIndex++ ;
              token.tokenStr = buf.substr( pre, 1 ) ;
              token.type = 4 ;
              token.value = 9 ;
              
              tokenTable.push_back( token ) ;
              if ( buf[bufIndex-2] == 'C' || buf[bufIndex-2] == 'c' )  
                token.type = 7 ;
 
              else if ( buf[bufIndex-2] == 'X' || buf[bufIndex-2] == 'x' )
                token.type = 6 ;

              pre++ ;
              while ( bufIndex < buf.size() && buf[bufIndex] != '\'' ) {
                bufIndex++ ;
			  } // while
			  
              if ( bufIndex < buf.size() ) {
	  		    pos = bufIndex ;
			    tokenStr = buf.substr( pre, pos-pre ) ; // ?A|r|e?oRe 
	          
                token.tokenStr = tokenStr ;
                if ( token.type == 7 ) {
	              token.value = table7.Insert( tokenStr ) ;
	            } // if
	            
	            else { // token.type == 6
	              token.value = table6.Insert( ToUpper( tokenStr ) ) ;
				} // else
              } // if

              else
                break ;
            } // if

            else {
	          bool isConstant = true ;
              for ( int j = 0 ; j < tokenStr.size() && isConstant ; j++ ) {
	            if ( tokenStr[j] < '0' || tokenStr[j] > '9' ) {
	              isConstant = false ;
                } // if
              } // for

              if ( isConstant ) { // table6 constant
	            token.tokenStr = tokenStr ;
                token.type = 6 ;
	            token.value = table6.Insert( tokenStr ) ;
              } // if

              else { // is label, table5
                token.tokenStr = tokenStr ;
                token.type = 5 ;
	            token.value = table5.Insert( tokenStr ) ;
              } // else
            } // else
          } // else
          // put it into proper table and get its value
          // (table1,2,3,4 are vector )
          // (table5,6,7 are hash table) 
          if ( token.tokenStr.size() != 0 )
            tokenTable.push_back( token ) ;

          pre = pos ;
          // put dilimeter into token table
          token.tokenStr = buf.substr( pre, 1 ) ;
          if ( token.tokenStr == " " || token.tokenStr == "\t" || token.tokenStr == "\n" ) { // // skip white space
            while ( bufIndex < buf.size() && ( buf[bufIndex] == ' ' || buf[bufIndex] == '\t' || token.tokenStr == "\n" ) ) {
	          bufIndex++ ;
			} // while
			
			pre = bufIndex ;
		    bufIndex-- ;
          } // if

          else { 
	        token.type = 4 ;
            for ( int i = 0 ; i < sicTable[3].size() ; i++ ) {
	          if ( token.tokenStr == sicTable[3][i] ) {
	            token.value = i+1 ;
                break ;
              } // if
            } // for

            tokenTable.push_back( token ) ;
            pre++ ;
            if ( token.tokenStr == "." ) {
              break ;
            } // if 
          } // else
        } // if

        else { // skip white sapce.
          if ( buf[bufIndex] == ' ' || buf[bufIndex] == '\t' || buf[bufIndex] == '\n' ) {
	        while ( bufIndex < buf.size() && ( buf[bufIndex] == ' ' || buf[bufIndex] == '\t' || buf[bufIndex] == '\n' ) ) {
	          bufIndex++ ;
	        } // while
	      
	        pre = bufIndex ;
	        bufIndex-- ;
          } // if

          else {
	        token.tokenStr = buf[bufIndex] ;
	        token.type = 4 ;
	        for ( int i = 0 ; i < sicTable[3].size() ; i++ ) {
	          if ( token.tokenStr == sicTable[3][i] ) {
	            token.value = i+1 ;
                break ;
              } // if
            } // for

            pre++ ;
            tokenTable.push_back( token ) ;
            if ( token.tokenStr == "." ) {
              break ;
            } // if
          } // else
        } // else
      } // if
    } // for
    
    int outputWalkIndex = outputHeadIndex ;
	while ( outputWalkIndex < tokenTable.size() ) {
      outputWalkIndex++ ;
	} // while
	
	if ( outputHeadIndex != outputWalkIndex ) {
	  Token eol ;
	  eol.tokenStr = "\n" ;
	  eol.type = 0 ;
	  eol.value = 0 ;
	  tokenTable.push_back( eol ) ;
	  outputWalkIndex++ ;
	} // if
	  
	outputHeadIndex = outputWalkIndex ;
  } // while

    vector<string> assemblyListing ;
    map<string, int> symbolTable ;
    map<int, pair<Token, int> > literalTable ;
    
    if ( cmd == "1" ) { // SIC
      Pass1( sicTable, tokenTable, symbolTable, outputTokenList ) ;
      Pass2( tokenTable, symbolTable, instructionSet, outputTokenList ) ;
    } // if

    else { // SIC/XE
      Pass1XE( sicTable, tokenTable, instructionSet, symbolTable, outputTokenList, literalTable ) ;
      Pass2XE( tokenTable, symbolTable, instructionSet, outputTokenList, literalTable ) ; 
    } // else

    OutputResult( outputTokenList, outfile ) ;
	
    infile.close() ;
    outfile.close() ;
    cout << endl ; 
    UserFrame() ;
    cin >> cmd ;
    while ( cmd != "1" && cmd != "2" && cmd != "3" ) {
      UserFrame() ;
      cin >> cmd ;	
    } // while
  } // while
} // main

vector<string> GetTableData( string fileName, bool &isOpen ) {
  isOpen = true ;
  vector<string> myVec ;
  fstream infile ;
  infile.open( fileName.c_str(), fstream::in ) ;
  if ( !infile.is_open() ) {
	cout << "open " << fileName << " error\n" ;
	isOpen = false ;
  } //while

  char cStr[256] ;
  string temp ;
  while ( infile.getline( cStr, 256, '\n' ) ) {
    temp.assign( cStr ) ;
    std::size_t found = temp.find_last_not_of( ' ' ) ;
    if (found!=std::string::npos)
      temp.erase(found+1) ;
    else
      temp.clear() ;

    myVec.push_back( temp ) ;
  } // while

  return myVec ;
} // GetTableData() 

bool IsDelimiter( char ch, vector<string> table4 ) {
  if ( ch == '\n' )
    return true ;
  else if ( ch == ' ' )
    return true ;
  else if ( ch == '\t')
    return true ;
  
  bool isDelimiter = false ;
  for ( int i = 0 ; i < table4.size() && !isDelimiter ; i++ ) {
    if ( ch == table4[i][0] ) {
      isDelimiter = true ;
	} // if
  } // for

  return isDelimiter ;
} // IsDelimiter()

string ToUpper( string str ) {
  for ( int i = 0 ; i < str.size() ; i++ ) {
    str[i] = toupper( str[i] ) ;
  } // for
   
  return str ;
} // ToUpper

string ToLower( string str ) {
  for ( int i = 0 ; i < str.size() ; i++ ) {
    str[i] = tolower( str[i] ) ;
  } // for
   
  return str ;
} // ToLower

int Hash :: GetHashValue( string str ) {
  int sum = 0, hashValue = 0 ;
  for ( int i = 0 ; i < str.size() ; i++ ) {
    sum += str[i] ;
  } // for
  
  hashValue = sum % 100 ;
  return hashValue ;
} // GetHashValue()

int Hash :: Insert( string str ) {
  int key = GetHashValue( str ) ;
  if ( hashMap[key] == "" ) { // put it in 
    hashMap[key] = str ;
  } // if
  
  else if ( hashMap[key] == str ) {
    ;
  } // else if
  
  else { // collision
    int count = 0 ;
    do {
      count++ ;
      key++ ;
      if ( count == 100 ) {
        key = -1 ;
        break ;
	  } // if
      if ( key == hashMap.size() ) 
        key = 0 ;
 
      if ( hashMap[key] == str )
        break ;
	} while ( hashMap[key] != "" ) ;
	
	if ( key != -1 )
      hashMap[key] = str ;
  } // else
  
  return key ;
} // Insert()

void UserFrame() {
  cout << "************************" << endl ;
  cout << "*                      *" << endl ;
  cout << "*     1.SIC            *" << endl ;
  cout << "*     2.SIC/XE         *" << endl ;
  cout << "*     3.quit           *" << endl ;
  cout << "*                      *" << endl ;
  cout << "************************" << endl ;
  cout << "Input a command:" ;
} // UserFrame()

string DecToHex( int decValue ) {
  string result ;
  stringstream ss ;
  ss << std::hex << decValue ;
  ss >> result ;

  return ToUpper( result ) ;
} // DexToHex

int HexToDec( string hexValue ) {
  int result ;
  stringstream ss ;
  ss << std::hex << hexValue ;
  ss >> result ;

  return result ;
} // HexToDec()

map<string, pair<string, int> > GetOpcodeSet() {
  string mnemonic[100] = { "add","addf","addr","and","clear","comp","compf","compr","div","divf","divr","fix",
                           "float","hio","j","jeq","jgt","jlt","jsub","lda","ldb","ldch","ldf","ldl","lds","ldt","ldx","lps",
                           "mul" ,"mulf","mulr","norm","or","rd","rmo","rsub","shiftl","shiftr","sio","ssk","sta",
                           "stb","stch","stf","sti","stl","sts" ,"stsw","stt","stx","sub","subf","subr","svc","td",
                           "tio","tix" ,"tixr","wd" } ; // 12+16+13+14+4=59

  string opcode[100] = { "18", "58", "90", "40", "B4", "28", "88", "A0", "24", "64", "9C", "C4", "C0", "F4", "3C", "30", "34", "38",
                         "48", "00", "68", "50", "70", "08", "6C", "74", "04", "D0", "20", "60", "98", "C8", "44", "D8", "AC", "4C",
                         "A4", "A8", "F0", "EC", "0C", "78", "54", "80", "D4", "14", "7C", "E8", "84", "10", "1C", "5C", "94", "B0",
                         "E0", "F8", "2C", "B8", "DC" } ; // 18*3+5 = 59

  int format[100] = { 3, 3, 2, 3, 2, 3, 3, 2, 3, 3, 2, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 
                      3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3, 3, 2, 3, 2, 2, 1, 3, 3, 3, 3, 3,
                      3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 1, 3, 2, 3 } ; // 22*2+15 = 59
  map<string, pair<string, int> > instructionSet ;
  pair<string, int> temp ;
  for ( int i = 0 ; i < 59 ; i++ ) {
	temp.first = opcode[i] ;
    temp.second = format[i] ;
    instructionSet.insert( pair<string, pair<string, int> >( mnemonic[i], temp ) ) ; 
  }  // for
   
  return instructionSet ;
} // GetOpcodeSet()

void Pass1( vector< vector<string> > sicTable, vector<Token> tokenTable,
            map<string, int> &symbolTable, vector<OutputToken> &outputTokenList )  {
  int loc = 0, line = 0, sourceLineCount = 0 ;
  int begin = 0, end = -1 ;
  Token label, opcode, address ;
  Token uselessToken ; 
  bool x = false,  uselessBool ;
  char uselessChar ; 
  GetTokenLine( tokenTable, begin, end, line ) ;
  ClassifyToken( tokenTable, begin, end, uselessBool, label, opcode, uselessBool,
                 x, uselessChar, address, uselessToken ) ;
  while ( outputTokenList[sourceLineCount].source == "" ) 
    sourceLineCount++ ;

  while ( opcode.tokenStr == "." ) { // AaÂ±??}AYaoÎ¼uï¹N 
    outputTokenList[sourceLineCount].line = line ;
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, uselessBool, label, opcode, uselessBool,
                 x, uselessChar, address, uselessToken ) ;
    while ( outputTokenList[sourceLineCount].source == "" ) 
      sourceLineCount++ ;
  } // while

  if ( opcode.tokenStr == "START" ) {
	loc = HexToDec( address.tokenStr ) ;
	symbolTable.insert( std :: pair<string, int>( label.tokenStr, loc ) ) ;
    outputTokenList[sourceLineCount].line = line ;
    outputTokenList[sourceLineCount].loc = loc ;
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
  } // if

  else 
    loc = 0 ;
  
  ClassifyToken( tokenTable, begin, end, uselessBool, label, opcode, uselessBool,
                 x, uselessChar, address, uselessToken ) ;
  while ( opcode.tokenStr != "END" ) {
	while ( outputTokenList[sourceLineCount].source == "" ) 
      sourceLineCount++ ;

    outputTokenList[sourceLineCount].line = line ;
    outputTokenList[sourceLineCount].loc = loc ; // comment line doesn;t have loc
    sourceLineCount++ ;
	if ( opcode.tokenStr != "." ) {
	  if ( label.tokenStr != "" ) { // has symbol
        if ( symbolTable.find( label.tokenStr ) != symbolTable.end() ) {
	      cout << "error:line" << line << " duplicate define symbol!\n" ; 
        } // if

        else {
	      symbolTable.insert( std :: pair<string, int>( label.tokenStr, loc ) ) ;
        } // else
      } // if

      if ( opcode.tokenStr == "" )
        cout << "error:line" << line << " vaild opcode\n" ;

      else if ( opcode.tokenStr == "RESB" || opcode.tokenStr == "RESW" ) {
	      stringstream ss ;
          int temp ;
          ss << address.tokenStr ;
          ss >> temp ;
	      if ( opcode.tokenStr == "RESB" ) {
	        loc += temp ;
          } // if

          else { // RESW
            loc += 3 * temp ;
          } // else
      } // else if
 
      else if ( opcode.tokenStr == "WORD" ) {
	    loc = loc + 3 ;
      } // else if

      else if ( opcode.tokenStr == "BYTE" ) {
	    if ( address.type == 6 ) { // constant
          int strLength = address.tokenStr.size() ;
          if ( strLength % 2 ) // have remainder
            strLength = strLength / 2 + 1 ;

          else
            strLength = strLength / 2 ;

          loc += strLength ;
        } // if

        else { // string
	      int strLength = address.tokenStr.size() ;
          loc += strLength ;
        } // else
      } // else if

      else {
	    loc = loc + 3 ;
      } // else    
    } // if

    else { // comment line doesn't have loc
      outputTokenList[sourceLineCount-1].loc = -1 ; // comment line doesn't have loc
    } // else

    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, uselessBool, label, opcode, uselessBool,
                 x, uselessChar, address, uselessToken ) ;
  } // while

  outputTokenList[sourceLineCount].line = line ; // END
  /* one pass
  get line(token)
  if ( opcode == start ) {
    set starting address
    get next line
  }
    
  else
    starting address = 0
      
  while ( opcode != END ) {
    if ( is not a commend line ) {
      if ( there is a symbol label ) {
        check if is a duplicate symbol 
        if ( is duplicate )
          set error
        else
          put into symbol table ( plus address )
      } // if
      
      get opcode 
      search opTAB for opcode
      if found {
        add instruction length to loc
      } // if
      
      else if ( opcode == 'word' ) {
        add 3 to loc 
      } // else if
    } // if
  } // while    
  one pass */
} // Pass1()

void Pass2( vector<Token> tokenTable, map<string, int> symbolTable,
            map<string, pair<string, int> > instructionSet, vector<OutputToken> &outputTokenList ) {
  int loc = 0, line = 0, sourceLineCount = 0 ;
  int begin = -1, end = -1 ;
  Token label, opcode, address ;
  Token uselessToken ; 
  bool x = false,  uselessBool ;
  char uselessChar ; 
  GetTokenLine( tokenTable, begin, end, line ) ;
  ClassifyToken( tokenTable, begin, end, uselessBool, label, opcode, uselessBool,
                 x, uselessChar, address, uselessToken ) ;
  while ( outputTokenList[sourceLineCount].source == "" ) 
    sourceLineCount++ ;
  
  while ( opcode.tokenStr == "." ) { // AaÂ±??}AYaoÎ¼uï¹N 
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, uselessBool, label, opcode, uselessBool,
                 x, uselessChar, address, uselessToken ) ;
  } // while

  if ( opcode.tokenStr == "START" ) {
    outputTokenList[sourceLineCount].machineCode = "" ;
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, uselessBool, label, opcode, uselessBool,
                 x, uselessChar, address, uselessToken ) ;
  } // if
  
  while ( opcode.tokenStr != "END" ) { // Â§PA_|!Â§i|â¥tokenTable[begin] != "END" 
    while ( outputTokenList[sourceLineCount].source == "" ) 
      sourceLineCount++ ;

    if ( opcode.tokenStr != "." ) {
      if ( opcode.tokenStr != "" ) {
        if ( opcode.tokenStr == "WORD" || opcode.tokenStr == "BYTE" ) {
          // X'F1' or 3 or C'EOF'
          if ( address.tokenStr == "EOF" ) 
            outputTokenList[sourceLineCount].machineCode = "454F46" ;
          else {
            if ( opcode.tokenStr == "BYTE" ) {
              outputTokenList[sourceLineCount].machineCode =  address.tokenStr ;
			} // if
			
			else { // WORD 
			  string tempAddr ;
			  stringstream ss ;
              ss << address.tokenStr ;
              int temp ;
              ss >> temp ;
              tempAddr = DecToHex( temp ) ;
              temp = 6 - tempAddr.size() ;
              while (  temp > 0 ) {
                tempAddr = "0" + tempAddr ;
                temp-- ;
			  } // while
			  
			  outputTokenList[sourceLineCount].machineCode = tempAddr ;
			} // else
		  } // else
		} // if

        else if ( opcode.type == 2 )
          ;
		else { // opcode table1 
		  string tempAddr, tempListing ;
		  if ( address.tokenStr != "" ) { // has operand
		    if ( x ) 
		      tempAddr = DecToHex( ( symbolTable.find( address.tokenStr ) -> second ) + 32768 ) ; // nibble
			else {
			  tempAddr = DecToHex( symbolTable.find( address.tokenStr ) -> second ) ;
            } // else
		  } // if 
		  
		  else { 
            if ( opcode.tokenStr != "rsub" )
		      cout << "error:line" << line << " undefine symbol\n" ;
		      tempAddr = "0000" ;
		  } // else
		  
          while ( tempAddr.size() < 4 ) {
	        tempAddr = "0" + tempAddr ;
          }  // if

          if ( opcode.type == 2 )
            cout << "error:line" << line << " undefine symbol\n" ;
          else
		    tempListing = instructionSet.find( opcode.tokenStr ) -> second.first + tempAddr ;

		  outputTokenList[sourceLineCount].machineCode = tempListing ;
		} // else
	  } // if
  
      else { // opcode == ""
        outputTokenList[sourceLineCount].machineCode = "" ;
      } // else
 	} // if
	
    else { // common-line
	  outputTokenList[sourceLineCount].machineCode = "" ;
    } // else

	GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, uselessBool, label, opcode, uselessBool,
                 x, uselessChar, address, uselessToken ) ;
    sourceLineCount++ ;
  } // while
  
  /* if ( opcode == 'start' ) {
      write assembly listing
      read next input 
    } // if
    
    while ( line != 'end' ) {
      if ( is not a commend line ) {
        search opTAB for opcode 
        if ( found ) {
          if ( there is a symbol in oprend field ) {
		    search symbolTAB for operand
			if ( found ) {
			  store symbol value for operand address
			} // if  
			
			else {
			  set operand address as 0
			  error:undefine symbol
			} // else
			
			assemble the object code 
		  } // if 
        } // if
        
        else if ( opcode == 'BYTE' or 'WORD' ) {
		  convert constant to object code
		} else if 
      } // if
      
      write listing line
      read next input
    } // while
  two pass */ 
} // Pass2()

void GetTokenLine( vector<Token> tokenTable, int &begin, int &end, int &line ) {  // use begin and end to specified a line
  end++ ;
  begin = end ;
  while( tokenTable[end].tokenStr != "\n" )
    end++ ;

  line += 5 ;
} // GetTokenLine()

void ClassifyToken( vector<Token> tokenTable, int begin, int end, bool &hasLiteral,
                    Token &label, Token &opcode, bool &e, bool &x, char &addrMod, Token &op1, Token&op2 ) {
  int i = begin ;
  bool isComment = false ;
  label.tokenStr = "" ;
  opcode.tokenStr = "" ;
  hasLiteral = false ;
  e = false ;
  x = false ;
  addrMod = '\0' ;
  op1.tokenStr = "" ;
  op2.tokenStr = "" ;
  if ( tokenTable[i].type == 5 ) {
      label = tokenTable[i] ;
      i++ ;
  } // if

  else if ( tokenTable[i].tokenStr == "." ) {
	opcode = tokenTable[i] ;
    isComment = true ;
  } // else if

  if ( !isComment ) {
    for ( ; i < end ; i++ ) {
	  if ( tokenTable[i].type == 1 || tokenTable[i].type == 2 )
        opcode = tokenTable[i] ;

      else if ( tokenTable[i].type == 3 ) {
	    if ( tokenTable[i].tokenStr == "X" )
          x = true ;

        if ( op1.tokenStr == "" ) {
	      op1 = tokenTable[i] ;
        } // if

        else if ( op2.tokenStr == "" ) {
	      op2 = tokenTable[i] ;
        } // else if
      } // else if

      else if ( tokenTable[i].type == 4 ) {
	    if ( tokenTable[i].tokenStr == "+" ) {
	      e = true ;
          addrMod = '+' ; // ååéç® 
        } // if

        else if (tokenTable[i].tokenStr == "@"  ) {
	      addrMod = '@' ;
        } // else if

        else if (tokenTable[i].tokenStr == "#"  ) {
	      addrMod = '#' ;
        } // else if
 
        else if (tokenTable[i].tokenStr == "*"  ) {
	      addrMod = '*' ;
        } // else if
        else if (tokenTable[i].tokenStr == "="  ) {
	      hasLiteral = true ;
        } // else if

        else if ( tokenTable[i].tokenStr == "-" ) {
          addrMod = '-' ;
        } // else if
        else if ( tokenTable[i].tokenStr == "*" ) {
          addrMod = '*' ;
        } // else if
        else if ( tokenTable[i].tokenStr == "/" ) {
          addrMod = '/' ;
        } // else if
      } // else if

      else { // table 5,6,7
        if ( op1.tokenStr == "" ) {
	      op1 = tokenTable[i] ;
        } // if

        else if ( op2.tokenStr == "" ) {
	      op2 = tokenTable[i] ;
        } // else if

        else {
	      cout << "error message:too many operand(function classifyToken)\n" ;
        } // else
      } // else
    } // for
  } // if
} // ClassifyToken

void OutputResult( vector<OutputToken> outputTokenList, fstream &outfile ) {
  outfile << "Line\tLocation\tSource code\tObject code\n" ;
  outfile << "----\t--------\t-----------\t-----------\n" ;
  for ( int i = 0 ; i < outputTokenList.size() ; i++ ) {
	if ( outputTokenList[i].line == -1 ) { // blank space
      	outfile << endl ;
    } // if

    else {
	  if ( outputTokenList[i].line != 0 )
        outfile << outputTokenList[i].line ;

      outfile << "\t" ;
      if ( outputTokenList[i].loc != -1 ) { // comment line
        string temp = DecToHex( outputTokenList[i].loc ) ;
        while ( temp.size() < 4 ) {
	      temp = "0" + temp ;
        } // while

        outfile << temp << "\t" ;
      } // if
 
      else {
        outfile << "\t" ;
      } // else

      outfile << outputTokenList[i].source << "\t" ;
      outfile << outputTokenList[i].machineCode << "\n" ;
    } // else
  } // for
} // OutputResult

void Pass1XE( vector< vector<string> > sicTable, vector<Token> tokenTable, map<string, pair<string, int> > instructionSet,
              map<string, int> &symbolTable, vector<OutputToken> &outputTokenList, map<int, pair<Token, int> > &literalTable )  {
  int loc = 0, line = 0, sourceLineCount = 0 ;
  int begin = 0, end = -1 ;
  Token label, opcode ;
  Token op1, op2 ;
  bool x = false, e = false, hasLiteral = false ;
  char addrMod = '\0' ;
  GetTokenLine( tokenTable, begin, end, line ) ;
  ClassifyToken( tokenTable, begin, end, hasLiteral, label, opcode, e,
                 x, addrMod, op1, op2 ) ;
  while ( outputTokenList[sourceLineCount].source == "" ) 
    sourceLineCount++ ;

  while ( opcode.tokenStr == "." ) { // AaÂ±??}AYaoÎ¼uï¹N 
    outputTokenList[sourceLineCount].line = line ;
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, hasLiteral, label, opcode, e,
                   x, addrMod, op1, op2 ) ;
    while ( outputTokenList[sourceLineCount].source == "" ) 
      sourceLineCount++ ;
  } // while

  if ( opcode.tokenStr == "START" ) {
	loc = HexToDec( op1.tokenStr ) ;
	symbolTable.insert( std :: pair<string, int>( label.tokenStr, loc ) ) ;
    outputTokenList[sourceLineCount].line = line ;
    outputTokenList[sourceLineCount].loc = loc ;
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
  } // if

  else 
    loc = 0 ;
  
  ClassifyToken( tokenTable, begin, end, hasLiteral, label, opcode, e,
                x, addrMod, op1, op2 ) ;
  while ( opcode.tokenStr != "END" ) {
	while ( outputTokenList[sourceLineCount].source == "" ) 
      sourceLineCount++ ;

    outputTokenList[sourceLineCount].line = line ;
    outputTokenList[sourceLineCount].loc = loc ; // comment line doesn;t have loc
    sourceLineCount++ ;
	if ( opcode.tokenStr != "." ) {
	  if ( label.tokenStr != "" ) { // has symbol
        if ( symbolTable.find( label.tokenStr ) != symbolTable.end() ) {
	      cout << "error:line" << line << " duplicate define symbol!\n" ; 
        } // if

        else {
	      symbolTable.insert( std :: pair<string, int>( label.tokenStr, loc ) ) ;
        } // else
      } // if

      if ( opcode.tokenStr == "" )
        cout << "error:line" << line << " vaild opcode\n" ;

      else if ( opcode.tokenStr == "RESB" || opcode.tokenStr == "RESW" ) {
	      stringstream ss ;
          int temp ;
          ss << op1.tokenStr ;
          ss >> temp ;
	      if ( opcode.tokenStr == "RESB" ) {
	        loc += temp ;
          } // if

          else { // RESW
            loc += 3 * temp ;
          } // else
      } // else if
 
      else if ( opcode.tokenStr == "WORD" ) {
	    loc = loc + 3 ;
      } // else if

      else if ( opcode.tokenStr == "BYTE" ) {
	    if ( op1.type == 6 ) { // constant
          int strLength = op1.tokenStr.size() ;
          if ( strLength % 2 ) // have remainder
            strLength = strLength / 2 + 1 ;

          else
            strLength = strLength / 2 ;

          loc += strLength ;
        } // if

        else { // string
	      int strLength = op1.tokenStr.size() ;
          loc += strLength ;
        } // else
      } // else if

      else if ( opcode.tokenStr == "EQU" ) {
	    if ( addrMod == '*' )
          outputTokenList[sourceLineCount-1].loc = loc ;

        else if ( op1.type == 5 ) { // label
          if ( op2.tokenStr != "" ) { // may have label +(-*/) label
            int addr1 = symbolTable.find( op1.tokenStr ) -> second ;
            int addr2 = symbolTable.find( op2.tokenStr ) -> second ;
            if ( addrMod == '+' ) 
              outputTokenList[sourceLineCount-1].loc = addr1 + addr2 ;
            else if ( addrMod == '-' ) 
              outputTokenList[sourceLineCount-1].loc = addr1 - addr2 ;
            else if ( addrMod == '*' ) 
              outputTokenList[sourceLineCount-1].loc = addr1 * addr2 ;
            else if ( addrMod == '/' ) 
              outputTokenList[sourceLineCount-1].loc = addr1 / addr2 ;
          } // if

          else { // only have 1 operand
	        outputTokenList[sourceLineCount-1].loc = symbolTable.find( op1.tokenStr ) -> second ;
          } // else
        } // else if

        else {
          int equLoc ;
          stringstream ss ;
          ss << op1.tokenStr ;
          ss >> equLoc ;
          outputTokenList[sourceLineCount-1].loc = equLoc ;
        } // else

        if ( label.tokenStr != "" )
          symbolTable.find( label.tokenStr ) -> second = outputTokenList[sourceLineCount-1].loc ;
      } // else if

      else if ( opcode.tokenStr == "LTORG" ) {
	    outputTokenList[sourceLineCount-1].loc = -1 ;
	    map<int, pair<Token, int> > :: iterator it = literalTable.begin() ;
        for ( it ; it != literalTable.end() ; it++ ) {
	      if ( it -> second.second == -1 ) {
	        OutputToken tempOutputToken ;
            tempOutputToken.line = 0 ;
            tempOutputToken.loc = loc ;
            tempOutputToken.source = "*\t=" ;
	        if ( IsNumber( it -> second.first.tokenStr ) ) { // is constant
              tempOutputToken.source += it -> second.first.tokenStr ;
	          it -> second.second = loc ;
              loc = loc + 3 ;
            } // if

            else { // is x'' or c''
	          it -> second.second = loc ;
              int temp = 0 ;
              if ( it -> second.first.type == 6 ) { // constant, x''
                if ( temp = it -> second.first.tokenStr.size() % 2 == 1 )
                temp = temp + it -> second.first.tokenStr.size() / 2 ;
                tempOutputToken.source += "X" ;
                tempOutputToken.source = tempOutputToken.source + "'" + it -> second.first.tokenStr + "'" ;
              } // if

              else { // string, c''
                temp = it -> second.first.tokenStr.size() ;
                tempOutputToken.source += "C" ;
                tempOutputToken.source = tempOutputToken.source + "'" + it -> second.first.tokenStr + "'" ;
                string tempStr = it -> second.first.tokenStr ;
                int ascii ;
                for ( int i = 0 ; i < tempStr.size() ; i++ ) {
	              ascii = tempStr[i] ;
                  tempOutputToken.machineCode += DecToHex( ascii ) ; 
                } // for
              } // else

              loc = loc + temp ;
            } // else

            outputTokenList.insert( outputTokenList.begin() + sourceLineCount, tempOutputToken ) ;
            sourceLineCount++ ;
          } // if
        } // for
      } // else if

      else if ( opcode.tokenStr == "BASE" ) {
	    outputTokenList[sourceLineCount-1].loc = -1 ;
      } // if

      else { 
	    if ( e ) { // format 4
	      loc += 4 ;
        } // if

        else {
	      loc += instructionSet.find( opcode.tokenStr ) -> second.second ;
        } // else
      } // else   

      if ( hasLiteral ) { // literal 
        int hashValue = GetHashValue( op1.tokenStr ) ;
        pair<Token, int> tempPair ;
        bool hasInsert = false ;
        tempPair.first = op1 ;
        tempPair.second = -1 ;
        hasInsert = literalTable.insert( pair<int, pair<Token, int> >( hashValue, tempPair ) ).second ;
        while ( !hasInsert && literalTable.find( hashValue ) -> second.first.tokenStr != op1.tokenStr ) {
	      hashValue++ ;
          if ( hashValue == 100 )
            hashValue = hashValue % 100 ;

          hasInsert = literalTable.insert( pair<int, pair<Token, int> >( hashValue, tempPair ) ).second ;
        } // while
      } // if 
    } // if

    else { //  for output,comment line doesn't have loc
      outputTokenList[sourceLineCount-1].loc = -1 ; // comment line doesn't have loc
    } // else

    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, hasLiteral, label, opcode, e,
                   x, addrMod, op1, op2 ) ;
  } // while

  outputTokenList[sourceLineCount].line = line ; // END
  map<int, pair<Token, int> > :: iterator it = literalTable.begin() ;
  for ( it ; it != literalTable.end() ; it++ ) {
	if ( it -> second.second == -1 ) {
	  OutputToken tempOutputToken ;
      tempOutputToken.line = 0 ;
      tempOutputToken.loc = loc ;
      tempOutputToken.source = "*\t=" ;
	  if ( IsNumber( it -> second.first.tokenStr ) ) { // is constant
        tempOutputToken.source +=  it -> second.first.tokenStr ;
        tempOutputToken.machineCode = it -> second.first.tokenStr ;
	    it -> second.second = loc ;
        loc = loc + 3 ;
      } // if

      else { // is x'' or c''
	    it -> second.second = loc ;
        int temp ;
        if ( it -> second.first.type == 6 ) { // constant, x''
          if ( temp = it -> second.first.tokenStr.size() % 2 == 1 )
            temp = temp + it -> second.first.tokenStr.size() / 2 ;

          tempOutputToken.source += "X" ;
          tempOutputToken.source = tempOutputToken.source + "'" + it -> second.first.tokenStr + "'" ;
          tempOutputToken.machineCode = it -> second.first.tokenStr ;
        } // if

        else { // string, c''
          temp = it -> second.first.tokenStr.size() ;
          tempOutputToken.source += "C" ;
          tempOutputToken.source = tempOutputToken.source + "'" + it -> second.first.tokenStr + "'" ;
          string tempStr = it -> second.first.tokenStr ;
          int ascii ;
          for ( int i = 0 ; i < tempStr.size() ; i++ ) {
	        ascii = tempStr[i] ;
            tempOutputToken.machineCode += DecToHex( ascii ) ; 
          } // for
        } // else

        loc = loc + temp ;
      } // else

      outputTokenList.push_back( tempOutputToken ) ;
      sourceLineCount++ ;
    } // if
  } // for
  /* one pass
  get line(token)
  if ( opcode == start ) {
    set starting address
    get next line
  }
    
  else
    starting address = 0
      
  while ( opcode != END ) {
    if ( is not a commend line ) {
      if ( there is a symbol label ) {
        check if is a duplicate symbol 
        if ( is duplicate )
          set error
        else
          put into symbol table ( plus address )
      } // if
      
      get opcode 
      search opTAB for opcode
      if found {
        add instruction length to loc
      } // if
      
      else if ( opcode == 'word' ) {
        add 3 to loc 
      } // else if
    } // if
  } // while    
  one pass */
} // Pass1()

void Pass2XE( vector<Token> tokenTable, map<string, int> symbolTable, map<string, pair<string, int> > instructionSet,
              vector<OutputToken> &outputTokenList, map<int, pair<Token, int> > literalTable ) {
  int base = -1, loc = 0, line = 0, sourceLineCount = 0 ;
  int begin = -1, end = -1 ;
  Token label, opcode ;
  Token op1, op2 ;
  bool x = false, e = false, hasLiteral = false  ;
  char addrMod = '\0' ;

  GetTokenLine( tokenTable, begin, end, line ) ;
  ClassifyToken( tokenTable, begin, end, hasLiteral, label, opcode, e,
                 x, addrMod, op1, op2 ) ;

  while ( outputTokenList[sourceLineCount].source == "" ) 
    sourceLineCount++ ;
  
  while ( opcode.tokenStr == "." ) { // AaÂ±??}AYaoÎ¼uï¹N 
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, hasLiteral, label, opcode, e,
                   x, addrMod, op1, op2 ) ;
  } // while

  if ( opcode.tokenStr == "START" ) {
	base = outputTokenList[sourceLineCount].loc ;
    outputTokenList[sourceLineCount].machineCode = "" ;
    sourceLineCount++ ;
    GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, hasLiteral, label, opcode, e,
                   x, addrMod, op1, op2 ) ;
  } // if
  
  while ( opcode.tokenStr != "END" ) { // Â§PA_|!Â§i|â¥tokenTable[begin] != "END" 
    while ( outputTokenList[sourceLineCount].source == "" ) 
      sourceLineCount++ ;
    
    if ( opcode.tokenStr != "." ) {
      if ( opcode.tokenStr != "" ) {
	    if ( opcode.type == 2 ) {
	      if ( opcode.tokenStr == "BASE" ) {
	          if ( op1.type == 5 ) {
	            base = symbolTable.find( op1.tokenStr ) -> second ;
              } // if

              else {
	            stringstream ss ;
                ss << op1.tokenStr ;
	            ss >> base ;
              } // else 
          } // if
          
          else if ( opcode.tokenStr == "WORD" || opcode.tokenStr == "BYTE" ) { // pseudo instruction
            // X'F1' or 3 or C'EOF'
            if ( op1.tokenStr == "EOF" ) 
              outputTokenList[sourceLineCount].machineCode = "454F46" ;
            else {
              if ( opcode.tokenStr == "BYTE" ) {
                outputTokenList[sourceLineCount].machineCode =  op1.tokenStr ;
			  } // if
			
			  else { // WORD 
			    string tempAddr ;
			    stringstream ss ;
                ss << op1.tokenStr ;
                int temp ;
                ss >> temp ;
                tempAddr = DecToHex( temp ) ;
                temp = 6 - tempAddr.size() ;
                while (  temp > 0 ) {
                  tempAddr = "0" + tempAddr ;
                  temp-- ;
			    } // while
			  
			    outputTokenList[sourceLineCount].machineCode = tempAddr ;
			  } // else
		    } // else
		  } // else if

          else if ( opcode.tokenStr == "LTORG" ) {
	        while ( outputTokenList[sourceLineCount+1].line == 0 ) {
              sourceLineCount++ ;
            } // while
          } // else if
        } // if

		else { // instruction 
          int format = instructionSet.find( opcode.tokenStr ) -> second.second ;
          if ( format == 1 ) { 
	        outputTokenList[sourceLineCount].machineCode = instructionSet.find( opcode.tokenStr ) -> second.first ;
          } // if

          else if ( format == 2 ) {
	        string assemblyLis, temp ;
            stringstream ss ;
            ss << op1.value-1 ;
            ss >> temp ;
            assemblyLis = temp ;
            if ( op2.tokenStr != "" ) {
	          ss.str("");
              ss.clear();
              ss << op2.value-1 ;
              ss >> temp ;
              assemblyLis = assemblyLis + temp ;
            } // if

            else {
	          assemblyLis += "0" ;
            } // else

            assemblyLis = instructionSet.find( opcode.tokenStr ) -> second.first +
                          assemblyLis ;
            outputTokenList[sourceLineCount].machineCode = assemblyLis ;
          } // else if

          else { // format 3 or 4
            string assemblyLis, zeroPadding ;
            int xbpe = 0 ;
            if ( x )
                xbpe += 8 ;

            int opcodeDec = HexToDec( instructionSet.find( opcode.tokenStr ) -> second.first ) ;
            if ( addrMod == '@' ) { // n = 1
              opcodeDec += 2 ;
            } // if

            else if ( addrMod == '#' ) { // i = 1
	          opcodeDec += 1 ;
            } // else if

            else { // n = 1,i = 1
	          opcodeDec += 3 ;
            } // else

            assemblyLis = DecToHex( opcodeDec ) ;
            while ( assemblyLis.size() < 2 )
              assemblyLis = "0" + assemblyLis ;

            if ( e ) { // format4
              int address = 0 ;
              string zeroPadding ;

              xbpe += 1 ;
              assemblyLis += DecToHex( xbpe ) ;
              if ( addrMod == '#' ) {
	            if ( op1.type == 5 ) {
	              address = symbolTable.find( op1.tokenStr ) -> second ;
                } // if

                else {
	              stringstream ss ;
                  ss << op1.tokenStr ;
	              ss >> address ;
                } // else 
              } // if

              else if ( hasLiteral ) {
	            int hashValue = GetHashValue( op1.tokenStr ) ;
                map<int, pair<Token, int> > :: iterator it ;
	            it = literalTable.find( hashValue ) ;
                while ( it -> second.first.tokenStr != op1.tokenStr ) {
	              hashValue++ ;
                  it = literalTable.find( hashValue ) ;
                } // while

                address = it -> second.second ;
              } // else if

              else {
	            if ( opcode.tokenStr != "rsub" ) 
                  address = symbolTable.find( op1.tokenStr ) -> second ;
              } // else

              zeroPadding = DecToHex( address ) ;
              while ( zeroPadding.size() < 5 ) {
	            zeroPadding = "0" + zeroPadding ;
              } // while 

              assemblyLis = assemblyLis + zeroPadding ;
            } // if

            else { // handle b,p format 3 
              bool error = false ;
	          int disp = 0, pc = outputTokenList[sourceLineCount+1].loc ;
              for ( int i = sourceLineCount+2 ; pc == -1 ; i++ ) {
	            pc = outputTokenList[i].loc ;
              } // while

              if ( addrMod == '#' || ( opcode.tokenStr == "comp" && op1.tokenStr == "0" ) ) { // comp 0
                if ( op1.type == 5 ) {
	              disp = symbolTable.find( op1.tokenStr ) -> second - pc ;
                  if ( disp <= 2047 && disp >= -2048 ) { // use pc
	                xbpe += 2 ;
                  } // if

                  else {
	                disp = symbolTable.find( op1.tokenStr ) -> second - base ;
                    
                    if ( disp >= 4095 && disp <= 0 ) {
	                  cout << "error:line" << line << "invalid displacement\n" ;
                      error = true ;
                    } // if
 
                    else {
                      xbpe += 4 ;
                    } // else
                  } // else

                  if ( error )
                    disp = 0 ;
                  else
                    disp = disp % 4096 ;
                } // if

                else {
	              stringstream ss ;
                  ss << op1.tokenStr ;
	              ss >> disp ;
                  disp = disp ;
                } // else
              } // if

              else { // not immediate addressing
                if ( hasLiteral ) {
	              int hashValue = GetHashValue( op1.tokenStr ) ;
                  map<int, pair<Token, int> > :: iterator it ;
	              it = literalTable.find( hashValue ) ;
                  while ( it -> second.first.tokenStr != op1.tokenStr ) {
	                hashValue++ ;
                    it = literalTable.find( hashValue ) ;
                  } // while

                  disp = it -> second.second - pc ;
                  xbpe += 2 ;
                  if ( disp >= 2047 || disp <= -2048 )
                    cout << "format3 has literal and can not use pc to get disp\n" ;
                } // if

                else {
	              if ( opcode.tokenStr != "rsub" ) {
                    disp = symbolTable.find( op1.tokenStr ) -> second - pc ;

                    if ( disp <= 2047 && disp >= -2048 ) { // use pc
	                  xbpe += 2 ;
                    } // if

                    else { // use base
                      disp = symbolTable.find( op1.tokenStr ) -> second - base ;
                      if ( disp >= 4095 && disp <= 0 ) {
	                    cout << "error:line" << line << "invalid displacement\n" ;
                        error = true ;
                      } // if
 
                      else {
                        xbpe += 4 ;
                      } // else
                    } // else

                    if ( error )
                      disp = 0 ;

                    else {
	                  disp = disp % 4096 ; // 12bits
                    } // else
                  } // if
                } // else
              } // else

              zeroPadding = DecToHex( disp ) ;
              while ( zeroPadding.size() < 3 ) {
	            zeroPadding = "0" + zeroPadding ;
              } // while 

              if ( zeroPadding.size() > 3 ) {
	            zeroPadding = zeroPadding.substr( zeroPadding.size() - 3, 3 ) ;
              } // if

              assemblyLis = assemblyLis + DecToHex( xbpe ) + zeroPadding ;
            } // else

            outputTokenList[sourceLineCount].machineCode = assemblyLis ;
          } // else
		} // else
	  } // if
  
      else {
        outputTokenList[sourceLineCount].machineCode = "" ;
      } // else
 	} // if
	
    else {
	  outputTokenList[sourceLineCount].machineCode = "" ;
    } // else

	GetTokenLine( tokenTable, begin, end, line ) ;
    ClassifyToken( tokenTable, begin, end, hasLiteral, label, opcode, e,
                   x, addrMod, op1, op2 ) ;
    sourceLineCount++ ;
  } // while
  
  /* if ( opcode == 'start' ) {
      write assembly listing
      read next input 
    } // if
    
    while ( line != 'end' ) {
      if ( is not a commend line ) {
        search opTAB for opcode 
        if ( found ) {
          if ( there is a symbol in oprend field ) {
		    search symbolTAB for operand
			if ( found ) {
			  store symbol value for operand address
			} // if  
			
			else {
			  set operand address as 0
			  error:undefine symbol
			} // else
			
			assemble the object code 
		  } // if 
        } // if
        
        else if ( opcode == 'BYTE' or 'WORD' ) {
		  convert constant to object code
		} else if 
      } // if
      
      write listing line
      read next input
    } // while
  two pass */ 


		  /* check instruction format
                if ( format1 )
                  write assembly listing
                if ( format2 )
                  write assembly listing
                else ( format3 or 4 )
                  6 bits opcode
                  check @ to set n 
                  check # to set i
                  check x to set x
                  check + to set e
                  if ( !e ) format 3
                    count disp
                    if ( overflow )
                      count disp( operand - Base )
                      p = 0, b = 1 
                      if ( TA overflow )
                        error message
                    else 
                      p = 1, b = 0

                    write assembly listing

                  else // format 4
                    b = 0, p = 0
                    set address
                    write assembly listing
          */
} // Pass2()

bool IsNumber( string str ) {
  for ( int i = 0 ; i < str.size() ; i++ ) {
	if ( str[i] < '0' || str[i] > '9' )
      return false ; 
  } // for

  return  true ;
} // Isnumber() 

int GetHashValue( string str ) {
  int sum = 0, hashValue = 0 ;
  for ( int i = 0 ; i < str.size() ; i++ ) {
    sum += str[i] ;
  } // for
  
  hashValue = sum % 100 ;
  return hashValue ;
} // GetHashValue()
